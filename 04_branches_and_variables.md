# 4. Branches and variables

In the previous part we saw how to build a simple two-rule system. However, our bioinformatics workflows usually involve more then two rules, which are not always connected in a linear way. In this part we'll get into how to organize our workflow into more complex patterns involving more rules, how to simplify how we specify our rules using variables and how to plot more complex workflows.

## Using variables in shell commands

When we look again at the shell command from **rule_1** from the previous part, we explicitely point to **file1.txt** twice. Once in the output part:
```
    output: "file1.txt"
```

and once in the shell part:
```
    shell: "touch file1.txt"
```
For the shell part, we can replace **file1.txt** with a variable, which points to **file1.txt** in the output part by changing the shell part in the following way:
```
    shell: "touch {output}"
```
Now the variable {output} in the shell script gets replaced by **file1.txt**, as it is defined in the output part of the rule. In general, inside the shell part different types of variables provided by Snakemake variables are defined by **{curly brackets}** around them. 


> [!CAUTION]
> Some shell commands you may want to include in your snakemake workflow use curly brackets on their own. For example consider the scripting language awk, where the command for plotting the first column of a tab separated file is like the following:
>
>awk '{print $1}' file.tsv
>
>If we want to use such a command in the shell part from Snakemake we have to **escape the curly brackets** by adding an extra pair of curly brackets around them, so that your snakemake shell command would look as follows:
>
>awk '**{{**print $1**}}**' file.tsv

Using such variables in your shell commands is generally strongly recommended. In many cases your input files may be complete paths or, as we will see later, will be generated by specific Snakemake functions and using variables will make your code much more readable. It will also reduce the probability of introducing coding errors if you have to define a file only once and then refer to it using variables.

Besides the {output} variable there is also a variable for {input}, which works the same way. So if we consider the shell part of **rule_2** from the previous part
```
    shell: "cp file1.txt file2.txt"
```
We can also change it to
```
    shell: "cp {input} {output}"
```
## Multiple input and output files

So far all of our rules had at most one input file and one output file. However, many of our bioinformatics software packages have multiple input files and we can often generate multiple output files with a single command. To accomodate this, rules can have an arbitrary number of input and output files. Lets assume we want to make a new rule called **rule_3**, which depends on the output files of both **rule_1** and **rule_2**, **file1.txt** and **file2.txt** and generates an output file called **file3.txt** by concatenating both files using the **cat** command. We could define it like this: 

```
rule rule3:
    input: 
        "file1.txt",
        "file2.txt"
    output: "file3.txt"
    shell: "cat {input} > {output}"
```

Note that in the output part we are now writing **file1.txt** and **file2.txt** in new lines instead of next to the output part. Also note that both of these lines have an additional level of indentation, e.g. there is an additional tab or set of multiple spaces at the beginning of the line, which tells Snakemake that both lines belong to the input part, while the output part in the following line goes back one level of indentation. Finally note the comma after file1.txt. If we make these types of multi-line variables we have to separate them with commas. **Forgetting these commas is one of the most common mistakes I make when writing Snakemake workflows!**





